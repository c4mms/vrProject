AFRAME.registerComponent('teleport-controls', {
    init: function () {
        const el = this.el;
        const sceneEl = this.el.sceneEl;

        el.setAttribute('laser-controls', { hand: 'right' });
        el.setAttribute('raycaster', {
            objects: '.teleportable',
            far: 10,
            interval: 0,
            showLine: true
        });

        this.teleportCircle = document.createElement('a-entity');
        this.teleportCircle.setAttribute('geometry', { primitive: 'circle', radius: 0.5 });
        this.teleportCircle.setAttribute('material', { color: 'blue', shader: 'flat', transparent: true, opacity: 0.5 });
        this.teleportCircle.setAttribute('rotation', '-90 0 0');
        this.teleportCircle.setAttribute('visible', false);
        sceneEl.appendChild(this.teleportCircle);

        this.intersectionPoint = new THREE.Vector3(); // Usiamo un Vector3 per memorizzare il punto

        el.addEventListener('raycaster-intersection', (event) => {
            if (event.detail.els.length > 0 && event.detail.els[0].classList.contains('teleportable')) {
                this.intersectionPoint.copy(event.detail.intersections[0].point);
                this.teleportCircle.setAttribute('visible', true);
                this.teleportCircle.setAttribute('position', this.intersectionPoint);
            } else {
                this.teleportCircle.setAttribute('visible', false);
            }
        });

        el.addEventListener('raycaster-intersectioncleared', () => {
            this.teleportCircle.setAttribute('visible', false);
        });

        el.tick = function () { // Funzione tick per aggiornare ad ogni frame
            if (this.el.components.raycaster && this.el.components.raycaster.intersectedEls.length > 0 && this.el.components.raycaster.intersectedEls[0].classList.contains('teleportable')) {
                const intersection = this.el.components.raycaster.intersections[0].point;
                this.teleportCircle.setAttribute('position', intersection);
            }
        };

        el.addEventListener('triggerdown', () => {
            if (this.teleportCircle.getAttribute('visible')) {
                const cameraRig = sceneEl.querySelector('#cameraRig');
                const headPosition = sceneEl.querySelector('#camera').getAttribute('position');

                cameraRig.setAttribute('position', {
                    x: this.intersectionPoint.x - headPosition.x,
                    y: cameraRig.getAttribute('position').y,
                    z: this.intersectionPoint.z - headPosition.z
                });
            }
        });
    }
});
